---
layout: post/index
title: "Novidades do C# 7, 7.1, 7.2 e 7.3"
description: "Post sobre algumas novidades do C# 7, 7.1, 7.2 e 7.3."
date: 2020-07-14
comments: true
categories:
- dev
tags:
- csharp
lang: pt
---

OlÃ¡, neste artigo eu vou escrever um resumo das novidades que eu acho mais relevantes que vieram no C# nas versÃµes [7](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7), [7.1](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-1), [7.2](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-2) e [7.3](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-3).

<!--more-->

##### Index:

 - [`out` Variables](/pt/csharp-7/#out-Variables-â†‘);
 - [Tuples](/pt/csharp-7/#Tuples-â†‘);
 - [Discards](/pt/csharp-7/#Discards-â†‘);
 - [Local functions](/pt/csharp-7/#Local-functions-â†‘)
 - [Mais expression-bodied](/pt/csharp-7/#Mais-expression-bodied-â†‘)
 - [`throw` Expressions](/pt/csharp-7/#throw-Expressions-â†‘)
 - [`async` MÃ©todo Main](/pt/csharp-7/#async-Metodo-Main-â†‘)
 - [`default` Literal expressions](/pt/csharp-7/#default-Literal-expressions-â†‘)
 - [Argumentos nomeados nÃ£o finais](/pt/csharp-7/#Argumentos-nomeados-nao-finais-â†‘)
 - [TÃ©cnicas para escrever cÃ³digo eficiente e seguro](/pt/csharp-7/#Tecnicas-para-escrever-codigo-eficiente-e-seguro-â†‘)
 - [Mais exemplos](/pt/csharp-7/#Mais-exemplos-â†‘)

##### `out` Variables [â†‘](#Index)

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
int result;
if (int.TryParse(input, out result))
{
    Console.WriteLine(result);
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
if (int.TryParse(input, out var result))
{
    Console.WriteLine(result);
}
{% endcodeblock %}

##### Tuples [â†‘](#Index)

DeclaraÃ§Ã£o de variÃ¡veis, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
var result = new Tuple<bool, string>(false, "An error has occurred");
Console.WriteLine($"{result.Item1}, {result.Item2}");
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
var result = (Successfully: false, Message: "An error has occurred");
Console.WriteLine($"{result.Successfully}, {result.Message}");
{% endcodeblock %}

Chamada de mÃ©todo, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
var result = DoSomething();
Console.WriteLine($"{result.Item1}, {result.Item2}");

Tuple<bool, string> DoSomething() => new Tuple<bool, string>(false, "An error has occurred");
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
var (successfully, message) = DoSomething();
Console.WriteLine($"{successfully}, {message}");

(bool Successfully, string Message) DoSomething() => (false, "An error has occurred");
{% endcodeblock %}

##### Discards [â†‘](#Index)

 - nÃ£o aloca memÃ³ria;
 - Ã© write only;

variÃ¡veis `out` que nÃ£o serÃ£o usadas, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
var successfully = int.TryParse(input, out var result);
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
var successfully = int.TryParse(input, out _);
{% endcodeblock %}

variÃ¡veis em **pattern matching** que nÃ£o serÃ£o usadas, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
switch (true)
{
    case object n when successfully:
        return "Successfully";
    default:
        return "An error has occurred";
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
switch (true)
{
    case object _ when successfully:
        return "Successfully";
    default:
        return "An error has occurred";
}
{% endcodeblock %}

variÃ¡veis desconstruÃ­das que nÃ£o serÃ£o usadas, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
var (successfully, message) = DoSomething();
if (successfully)
{
    return;
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
var (successfully, _) = DoSomething();
if (successfully)
{
    return;
}
{% endcodeblock %}

##### Local functions [â†‘](#Index)

 - pode ser `async`;
 - pode usar iterators com `yield`;
 - pode conter outra funÃ§Ã£o local;
 - pode conter um bloco ou uma expressÃ£o;
 - pode ser genÃ©rica e pode restringir os tipos genÃ©ricos;
 - pode usar variÃ¡veis e parÃ¢metros genÃ©ricos que estejam no escopo da funÃ§Ã£o que ela foi criada;
 - pode usar parÃ¢metros `ref` e `out`;
 - nÃ£o pode mudar o fluxo da funÃ§Ã£o externa, por exemplo com uso de `goto`, `break`, `continue` e etc;
 - nÃ£o causam alocaÃ§Ãµes locais como declaraÃ§Ã£o de `Func` ou `Action`;

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public void LogInfo(in string message)
{
    Log("Info", message);
}

private static void Log(in string level, in string message)
{
    Console.WriteLine($"{level} -> {message}");
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public void LogInfo(string message)
{
    Log("Info");

    void Log(in string level)
    {
        Console.WriteLine($"{level} -> {message}");
    }
}
{% endcodeblock %}

##### Mais expression-bodied [â†‘](#Index)

Esta feature feio da versÃ£o 6, e na versÃ£o 7 eles adicionaram em **construtures**, **finalizadores** e **propriedades**.

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    private readonly string name;

    public User(in string name)
    {
        this.name = name;
    }

    ~User()
    {
        Console.WriteLine("User finalized.");
    }

    public string Name
    {
        get
        {
            return this.name?.ToUpper() ?? string.Empty;
        }
    }
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    private readonly string name;

    public User(in string name) => this.name = name;

    ~User() => Console.WriteLine("User finalized.");

    public string Name => this.name?.ToUpper() ?? string.Empty;
}
{% endcodeblock %}

##### `throw` Expressions [â†‘](#Index)

Agora podemos utilizar `throw` em uma operaÃ§Ã£o de null coalesce e em expression bodied members.

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    private string name;

    public string Name
    {
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value), "Name cannot be null");
            }

            this.name = value;
        }

        get
        {
            throw new NotImplementedException();
        }
    }
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    private string name;

    public string Name
    {
        set => this.name = value ?? throw new ArgumentNullException(nameof(value), "Name cannot be null");
        get => throw new NotImplementedException();
    }
}
{% endcodeblock %}

##### `async` MÃ©todo Main [â†‘](#Index)

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public class Program
{
    public static void Main(string[] args) => MainAsync()
        .GetAwaiter()
        .GetResult();

    private static Task MainAsync() => Task.CompletedTask;
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public class Program
{
    public static Task Main(string[] args) => Task.CompletedTask;
}
{% endcodeblock %}

##### `default` Literal expressions [â†‘](#Index)

Em parÃ¢metros opcionais, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    public User(in string name)
    {
        this.Id = default(uint);
        this.Name = name;
    }

    public uint Id { get; private set; }

    public string Name { get; }

    public override string ToString() => default(string);

    public User UpdateUser(in uint id, in string name = default(string)) => new User(name ?? this.Name)
    {
        Id = id,
    };
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    public User(in string name)
    {
        this.Id = default;
        this.Name = name;
    }

    public uint Id { get; private set; }

    public string Name { get; }

    public override string ToString() => default;

    public User UpdateUser(in uint id, in string name = default) => new User(name ?? this.Name)
    {
        Id = id,
    };
}
{% endcodeblock %}

##### Argumentos nomeados nÃ£o finais [â†‘](#Index)

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
UpdateUser(id: 1, name: name);
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
UpdateUser(id: 1, name);
{% endcodeblock %}

##### TÃ©cnicas para escrever cÃ³digo eficiente e seguro [â†‘](#Index)

`in` o parÃ¢metro Ã© passado por referÃªncia sÃ³ que readonly;
`ref` o parÃ¢metro Ã© passado por referÃªncia read and write;
`ref readonly` o retorno do mÃ©todo Ã© por referÃªncia e nÃ£o pode ser alterado;
`struct readonly` a estrutura Ã© readonly evitando quando um mÃ©todo Ã© acessado uma cÃ³pia desnecessÃ¡ria;
`protected internal` permite classes derivadas **ou** no mesmo assembly;
`private protected` permite classes derivadas **e** no mesmo assembly;

**nota**: Pattern Matching terÃ¡ um artigo sÃ³ para ele, e serÃ¡ sempre atualizado com as novas versÃµes do C#.

##### Mais exemplos [â†‘](#Index)

Abaixo uma lista de projetos que vocÃª pode ver as novidades do C# em exemplos reais.

â™Ÿ [Chess](https://github.com/jroliveira/chess) Ã© uma console app feita com ASCII art.
ğŸ· [Hawk (api)](https://github.com/jroliveira/hawk-api) Ã© sistema de finanÃ§a pessoal.
[Http.Query.Filter](https://github.com/jroliveira/http-query-filter/) Ã© uma lib para fazer filtros baseado no StrongLoop da IBM.

Obrigado pela visita ğŸ™‚! 
