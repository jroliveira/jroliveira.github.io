---
layout: post/index
title: "Novidades do C# 7, 7.1, 7.2 e 7.3"
description: "Post sobre algumas novidades do C# 7, 7.1, 7.2 e 7.3."
date: 2020-07-14
comments: true
categories:
- dev
tags:
- csharp
lang: pt
---

Ol√°, neste artigo eu vou escrever um resumo das novidades que eu acho mais relevantes que vieram no C# nas vers√µes [7](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7), [7.1](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-1), [7.2](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-2) e [7.3](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-3).

<!--more-->

##### Index:

 - [`out` Variables](/pt/csharp-7/#out-Variables-uarr);
 - [Tuples](/pt/csharp-7/#Tuples-uarr);
 - [Discards](/pt/csharp-7/#Discards-uarr);
 - [Local functions](/pt/csharp-7/#Local-functions-uarr)
 - [Mais expression-bodied](/pt/csharp-7/#Mais-expression-bodied-uarr)
 - [`throw` Expressions](/pt/csharp-7/#throw-Expressions-uarr)
 - [`async` M√©todo Main](/pt/csharp-7/#async-Metodo-Main-uarr)
 - [`default` Literal expressions](/pt/csharp-7/#default-Literal-expressions-uarr)
 - [Argumentos nomeados n√£o finais](/pt/csharp-7/#Argumentos-nomeados-nao-finais-uarr)
 - [T√©cnicas para escrever c√≥digo eficiente e seguro](/pt/csharp-7/#Tecnicas-para-escrever-codigo-eficiente-e-seguro-uarr)
 - [Mais exemplos](/pt/csharp-7/#Mais-exemplos-uarr)

##### `out` Variables [&uarr;](#Index)

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
int result;
if (int.TryParse(input, out result))
{
    Console.WriteLine(result);
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
if (int.TryParse(input, out var result))
{
    Console.WriteLine(result);
}
{% endcodeblock %}

##### Tuples [&uarr;](#Index)

Declara√ß√£o de vari√°veis, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
var result = new Tuple<bool, string>(false, "An error has occurred");
Console.WriteLine($"{result.Item1}, {result.Item2}");
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
var result = (Successfully: false, Message: "An error has occurred");
Console.WriteLine($"{result.Successfully}, {result.Message}");
{% endcodeblock %}

Chamada de m√©todo, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
var result = DoSomething();
Console.WriteLine($"{result.Item1}, {result.Item2}");

Tuple<bool, string> DoSomething() => new Tuple<bool, string>(false, "An error has occurred");
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
var (successfully, message) = DoSomething();
Console.WriteLine($"{successfully}, {message}");

(bool Successfully, string Message) DoSomething() => (false, "An error has occurred");
{% endcodeblock %}

##### Discards [&uarr;](#Index)

 - n√£o aloca mem√≥ria;
 - √© write only;

vari√°veis `out` que n√£o ser√£o usadas, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
var successfully = int.TryParse(input, out var result);
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
var successfully = int.TryParse(input, out _);
{% endcodeblock %}

vari√°veis em **pattern matching** que n√£o ser√£o usadas, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
switch (true)
{
    case object n when successfully:
        return "Successfully";
    default:
        return "An error has occurred";
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
switch (true)
{
    case object _ when successfully:
        return "Successfully";
    default:
        return "An error has occurred";
}
{% endcodeblock %}

vari√°veis desconstru√≠das que n√£o ser√£o usadas, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
var (successfully, message) = DoSomething();
if (successfully)
{
    return;
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
var (successfully, _) = DoSomething();
if (successfully)
{
    return;
}
{% endcodeblock %}

##### Local functions [&uarr;](#Index)

 - pode ser `async`;
 - pode usar iterators com `yield`;
 - pode conter outra fun√ß√£o local;
 - pode conter um bloco ou uma express√£o;
 - pode ser gen√©rica e pode restringir os tipos gen√©ricos;
 - pode usar vari√°veis e par√¢metros gen√©ricos que estejam no escopo da fun√ß√£o que ela foi criada;
 - pode usar par√¢metros `ref` e `out`;
 - n√£o pode mudar o fluxo da fun√ß√£o externa, por exemplo com uso de `goto`, `break`, `continue` e etc;
 - n√£o causam aloca√ß√µes locais como declara√ß√£o de `Func` ou `Action`;

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public void LogInfo(in string message)
{
    Log("Info", message);
}

private static void Log(in string level, in string message)
{
    Console.WriteLine($"{level} -> {message}");
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public void LogInfo(string message)
{
    Log("Info");

    void Log(in string level)
    {
        Console.WriteLine($"{level} -> {message}");
    }
}
{% endcodeblock %}

##### Mais expression-bodied [&uarr;](#Index)

Esta feature feio da vers√£o 6, e na vers√£o 7 eles adicionaram em **construtures**, **finalizadores** e **propriedades**.

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    private readonly string name;

    public User(in string name)
    {
        this.name = name;
    }

    ~User()
    {
        Console.WriteLine("User finalized.");
    }

    public string Name
    {
        get
        {
            return this.name?.ToUpper() ?? string.Empty;
        }
    }
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    private readonly string name;

    public User(in string name) => this.name = name;

    ~User() => Console.WriteLine("User finalized.");

    public string Name => this.name?.ToUpper() ?? string.Empty;
}
{% endcodeblock %}

##### `throw` Expressions [&uarr;](#Index)

Agora podemos utilizar `throw` em uma opera√ß√£o de null coalesce e em expression bodied members.

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    private string name;

    public string Name
    {
        set
        {
            if (value == null)
            {
                throw new ArgumentNullException(nameof(value), "Name cannot be null");
            }

            this.name = value;
        }

        get
        {
            throw new NotImplementedException();
        }
    }
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    private string name;

    public string Name
    {
        set => this.name = value ?? throw new ArgumentNullException(nameof(value), "Name cannot be null");
        get => throw new NotImplementedException();
    }
}
{% endcodeblock %}

##### `async` M√©todo Main [&uarr;](#Index)

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public class Program
{
    public static void Main(string[] args) => MainAsync()
        .GetAwaiter()
        .GetResult();

    private static Task MainAsync() => Task.CompletedTask;
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public class Program
{
    public static Task Main(string[] args) => Task.CompletedTask;
}
{% endcodeblock %}

##### `default` Literal expressions [&uarr;](#Index)

Em par√¢metros opcionais, antes.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    public User(in string name)
    {
        this.Id = default(uint);
        this.Name = name;
    }

    public uint Id { get; private set; }

    public string Name { get; }

    public override string ToString() => default(string);

    public User UpdateUser(in uint id, in string name = default(string)) => new User(name ?? this.Name)
    {
        Id = id,
    };
}
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
public class User
{
    public User(in string name)
    {
        this.Id = default;
        this.Name = name;
    }

    public uint Id { get; private set; }

    public string Name { get; }

    public override string ToString() => default;

    public User UpdateUser(in uint id, in string name = default) => new User(name ?? this.Name)
    {
        Id = id,
    };
}
{% endcodeblock %}

##### Argumentos nomeados n√£o finais [&uarr;](#Index)

Antes.

{% codeblock lang:csharp line_number:true highlight:true %}
UpdateUser(id: 1, name: name);
{% endcodeblock %}

Depois.

{% codeblock lang:csharp line_number:true highlight:true %}
UpdateUser(id: 1, name);
{% endcodeblock %}

##### T√©cnicas para escrever c√≥digo eficiente e seguro [&uarr;](#Index)

`in` o par√¢metro √© passado por refer√™ncia s√≥ que readonly;
`ref` o par√¢metro √© passado por refer√™ncia read and write;
`ref readonly` o retorno do m√©todo √© por refer√™ncia e n√£o pode ser alterado;
`struct readonly` a estrutura √© readonly evitando quando um m√©todo √© acessado uma c√≥pia desnecess√°ria;
`protected internal` permite classes derivadas **ou** no mesmo assembly;
`private protected` permite classes derivadas **e** no mesmo assembly;

**nota**: Pattern Matching ter√° um artigo s√≥ para ele, e ser√° sempre atualizado com as novas vers√µes do C#.

##### Mais exemplos [&uarr;](#Index)

Abaixo uma lista de projetos que voc√™ pode ver as novidades do C# em exemplos reais.

‚ôü [Chess](https://github.com/jroliveira/chess) √© uma console app feita com ASCII art.
üê∑ [Hawk (api)](https://github.com/jroliveira/hawk-api) √© sistema de finan√ßa pessoal.
[Http.Query.Filter](https://github.com/jroliveira/http-query-filter/) √© uma lib para fazer filtros baseado no StrongLoop da IBM.

Obrigado pela visita üôÇ! 
